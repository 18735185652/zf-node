<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
 //java 多线程模式
//进程：进程是操作系统分配资源和调度任务的基本单位(进程里面可以包含多个线程)
// 例：桌面可以同时开多个谷歌浏览器，每个浏览器就是单独的一个进程，浏览器里面可以开多个标签页，标签页就是线程

// 客户端请求服务器，服务器会为这个请求单独的开辟一个线程，线程负责处理客户端请求，线程向数据库请求数据，此时线程会等待数据库返回数据，
// 我们说线程阻塞了,收到数据后发给客户端，销毁线程

//node单线程非阻塞IO
//客户端请求服务器，开辟一个唯一的主线程，主线程请求数据库，此时不阻塞(可以处理其他的请求)


// node的优点
// 1.节约内存(单线程，一个线程大约占5mb的内存)
// 2.节约上下文切换的时间  context环境的意思
// 3.锁的问题，并发资源的处理
// 4.站在巨人的肩膀上，谷歌V8引擎，轻量又高效
// 5.node.js的包管理器npm，是全球最大的开源库生态系统

 //缺点：
 // 在node.js里，如果一个线程崩了，那么整个服务就当了

 // 多线程是如何实现的？
 // 并不是真正在同一个时间点执行多个任务，而是非常快速的切换时间片来实现。
 //浏览器里UI线程+JS线程是共用一个线程的(执行JS的时候不能渲染UI，渲染UI的时候不能执行JS)，互斥
 // 例如写一个死循环，页面出不来就是这个道理

// webworker多线程
// 1.完全受主线程控制


// 浏览器模型
//  用户界面-包括地址栏、前进/后退按钮、书签菜单等
//  浏览器引擎-在用户界面和呈现引擎之间传送指令
//  呈现引擎-又称渲染引擎，也被称为浏览器内核，在线程方面又称为UI线程
//  网络-用于网络调用，比如 HTTP 请求
//  用户界面后端-用于绘制基本的窗口小部件,UI线程和JS共用一个线程
//  JavaScript解释器-用于解析和执行 JavaScript 代码
//  数据存储-这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie



 // 除JS线程和UI线程之外的其它线程
 // 浏览器事件触发线程
 // 定时触发器线程
 // 异步HTTP请求线程

// event loop













</script>
</body>
</html>